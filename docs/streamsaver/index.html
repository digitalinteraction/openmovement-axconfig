<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="icon" href="data:">
    <title>Demo - Download Streamed/Generated File</title>
    <style>
        body {
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <h1>Demo - Download Streamed/Generated File</h1>
    <div><button id="download">Download</button></div>
</body>
<script>

async function sleep(t) {
  return new Promise((resolve) => {
    setTimeout(resolve, t);
  });
}

let downloadScripts = null;

async function download(filename, fileSize, callback) {
  console.log('DOWNLOAD: start');

  // Dynamically load scripts
  if (!downloadScripts) {
    console.log('DOWNLOAD: scripts need to be dynamically loaded');
    const scriptSources = [
      './web-streams-polyfill.min.js',
      './StreamSaver.js',
    ];
    downloadScripts = [];
    for (const scriptSource of scriptSources) {
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = scriptSource;
      script.promise = new Promise((resolve, reject) => {
        script.onload = resolve;
        script.onerror = reject;
      });
      document.body.appendChild(script);
      downloadScripts.push(script);
    }
  }

  // Wait for all of the scripts to load
  console.log('DOWNLOAD: waiting for scripts to be loaded');
  await Promise.all(downloadScripts.map(script => script.promise));
  console.log('DOWNLOAD: scripts loaded');

  // const useIframe = 'isSecureContext' in window && isSecureContext;
  // const usePopup = 'isSecureContext' in window && !isSecureContext;
  // const useLocationHref = !useIframe;
  // const useCrossOriginServiceWorker = new URL(streamSaver.mitm).origin !== window.origin;
  // let useMessageChannel = false;
  // let useTransformStream = false;
  // let keepServiceWorkerAlive = false;
  // try {
  //   const { readable } = new TransformStream();
  //   const mc = new MessageChannel();
  //   mc.port1.postMessage(readable, [readable]);
  //   mc.port1.close();
  //   mc.port2.close();
  //   useTransformStream = true;
  // } catch (e) {
  //   useMessageChannel = true;
  //   keepServiceWorkerAlive = true;
  // }

  // Over HTTPS, use local version of MITM for SW -- otherwise, will fall back to github.io version
  if (location.protocol == 'https:') {
    streamSaver.mitm = './mitm.html';
  }

  const options = {};
  if (fileSize !== null && fileSize >= 0) {
    options.size = fileSize;
  }

  const fileStream = streamSaver.createWriteStream(filename, options);
  let writer = fileStream.getWriter();

  writer.fileSize = fileSize;
  
  const abort = () => {
    if (writer) {
      callback(null); 
      writer.abort(); 
      writer = null; 
    }
  }

  try {
    window.addEventListener('unload', abort);
    for (;;) {
      if (!writer) {
        throw new Error('Writer is aborted');
      }
      // const byte = new TextEncoder().encode('!'); writer.write(byte);
      const result = await callback(writer);
      if (!result) {
        break;
      }
    }
    writer.close();
  } catch (e) {
    console.log('DOWNLOAD: error - ' + e);
    abort();
    throw e;
  } finally {
    window.removeEventListener('unload', abort);
  }

  return true;
}

document.querySelector('#download').addEventListener('click', async () => {
  try {
    document.querySelector('#download').disabled = true;

    const maxLen = 10;
    const result = await download('test.txt', maxLen, async (writer) => {
      const byte = new TextEncoder().encode('!');
      if (!writer) throw new Error('Writer is aborted - callback 1');
      await writer.write(byte);
      await sleep(500);
      if (!writer) throw new Error('Writer is aborted - callback 2');
      if (!writer.written) { writer.written = 0; }
      writer.written += byte.length;
      return writer.written < writer.fileSize;
    });
    console.log('DOWNLOAD: result=' + result);

  } finally {
    document.querySelector('#download').disabled = false;
  }
});

</script>
</html>